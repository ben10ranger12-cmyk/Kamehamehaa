<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ultimate AR Kamehameha</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden; 
            font-family: 'Courier New', Courier, monospace;
            /* Prevent pull-to-refresh on mobile */
            overscroll-behavior: none; 
            touch-action: none;
        }
        
        canvas { 
            display: block; 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            /* Mirroring handled in CSS */
            transform: scaleX(-1); 
        }
        
        video { display: none; }
        
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10; display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px; box-sizing: border-box;
            /* Safe area for mobile notches */
            padding-top: max(20px, env(safe-area-inset-top));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
        }
        
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #0ff;
            text-align: center;
        }

        h1 { font-size: 6vw; margin-bottom: 10px; }
        @media (min-width: 600px) { h1 { font-size: 32px; } }

        .btn {
            padding: 20px 50px; /* Larger touch target */
            border: 2px solid #0ff; background: rgba(0, 255, 255, 0.1);
            color: #0ff; font-size: 18px; cursor: pointer; text-transform: uppercase;
            letter-spacing: 2px; transition: 0.3s; margin-top: 30px;
            border-radius: 4px;
            /* Prevent text selection */
            user-select: none; -webkit-user-select: none;
        }
        .btn:hover, .btn:active { background: #0ff; color: #000; box-shadow: 0 0 30px #0ff; }
        
        /* Made responsive width */
        .bar-container { width: 80%; max-width: 400px; height: 15px; border: 1px solid #333; margin: 10px auto; border-radius: 10px; overflow: hidden; }
        .bar-fill { height: 100%; background: #0ff; width: 0%; transition: width 0.1s; box-shadow: 0 0 10px #0ff; }
        
        .status-text { 
            text-align: center; 
            color: rgba(255,255,255,0.9); 
            text-shadow: 0 0 5px #0ff; 
            font-size: 1.2rem;
            font-weight: bold;
        }
        
        #instruction {
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 20px;
            display: inline-block;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <h1>PROJECT KAMEHAMEHA</h1>
        <p id="loading-text">Loading AI Models...</p>
        <button id="start-btn" class="btn" style="display:none;">INITIALIZE SYSTEM</button>
        <p style="font-size: 10px; color: #666; margin-top: 20px;">Prop phone or hold steady<br>Requires Camera & Audio</p>
    </div>

    <div id="hud">
        <div class="status-text">
            <span>ENERGY OUTPUT</span>
            <div class="bar-container"><div id="energy-bar" class="bar-fill"></div></div>
        </div>
        <div class="status-text">
            <div id="instruction">ALIGN WRISTS TO CHARGE</div>
        </div>
    </div>

    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

<script>
/**
 * ------------------------------------------------------------------
 * 1. AUDIO SYNTHESIS ENGINE (Unchanged Logic)
 * ------------------------------------------------------------------
 */
class AudioController {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.5;
        this.master.connect(this.ctx.destination);
        
        this.isCharging = false;
        this.chargeOsc = null;
        this.chargeGain = null;
    }

    startCharge() {
        if (this.isCharging) return;
        this.isCharging = true;
        this.chargeOsc = this.ctx.createOscillator();
        this.chargeOsc.type = 'sawtooth';
        this.chargeOsc.frequency.setValueAtTime(50, this.ctx.currentTime);
        this.chargeFilter = this.ctx.createBiquadFilter();
        this.chargeFilter.type = 'lowpass';
        this.chargeFilter.frequency.value = 100;
        this.chargeGain = this.ctx.createGain();
        this.chargeGain.gain.setValueAtTime(0, this.ctx.currentTime);
        this.chargeGain.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 0.5);
        this.chargeOsc.connect(this.chargeFilter);
        this.chargeFilter.connect(this.chargeGain);
        this.chargeGain.connect(this.master);
        this.chargeOsc.start();
    }

    updateCharge(level) {
        if (!this.chargeOsc) return;
        const freq = 50 + (level * 200); 
        this.chargeOsc.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.1);
        const filterFreq = 100 + (level * 1000);
        this.chargeFilter.frequency.setTargetAtTime(filterFreq, this.ctx.currentTime, 0.1);
        const wobble = Math.sin(this.ctx.currentTime * (10 + level * 20)) * 0.1;
        this.chargeGain.gain.value = 0.5 + wobble;
    }

    stopCharge() {
        if (this.chargeOsc) {
            this.chargeOsc.stop();
            this.chargeOsc.disconnect();
            this.chargeOsc = null;
            this.isCharging = false;
        }
    }

    fireBlast() {
        this.stopCharge();
        const bufferSize = this.ctx.sampleRate * 2; 
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.setValueAtTime(1000, this.ctx.currentTime);
        noiseFilter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 1);
        const noiseGain = this.ctx.createGain();
        noiseGain.gain.setValueAtTime(1, this.ctx.currentTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.5);
        noise.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.master);
        noise.start();
    }
}

/**
 * ------------------------------------------------------------------
 * 2. PHYSICS & VISUALS ENGINE
 * ------------------------------------------------------------------
 */
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d');
let width, height;

// State
let charge = 0; 
let isHandsTogether = false;
let isFiring = false;
let fireFrameCount = 0;
let handCentroid = { x: 0, y: 0 };
let particles = [];
let lightning = [];

// Video Scale State (For mobile aspect ratio correction)
let renderScale = { w: 1, h: 1, offsetX: 0, offsetY: 0 };

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Particle Class
class Particle {
    constructor(type, x, y) {
        this.type = type;
        this.x = x; 
        this.y = y;
        this.life = 1.0;
        
        if (type === 'gather') {
            const angle = Math.random() * Math.PI * 2;
            const dist = 100 + Math.random() * 150;
            this.targetX = x;
            this.targetY = y;
            this.x = x + Math.cos(angle) * dist;
            this.y = y + Math.sin(angle) * dist;
            this.vx = (this.targetX - this.x) * 0.08;
            this.vy = (this.targetY - this.y) * 0.08;
            this.size = Math.random() * 3 + 1;
            this.color = `hsl(200, 100%, ${50 + Math.random()*50}%)`;
        } else {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 20 + 5;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.size = Math.random() * 5 + 2;
            this.color = '#fff';
        }
    }

    update() {
        if (this.type === 'gather') {
            this.x += this.vx;
            this.y += this.vy;
            if (Math.abs(this.x - this.targetX) < 10 && Math.abs(this.y - this.targetY) < 10) {
                this.life = 0;
            }
        } else {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= 0.02;
        }
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// Lightning Class
class Bolt {
    constructor(x, y, radius) {
        this.path = [];
        this.life = 1.0;
        let cx = x;
        let cy = y;
        for(let i=0; i<8; i++) {
            this.path.push({x: cx, y: cy});
            cx += (Math.random() - 0.5) * radius * 2;
            cy += (Math.random() - 0.5) * radius * 2;
        }
    }
    draw(ctx) {
        if(this.life <= 0) return;
        this.life -= 0.15;
        ctx.strokeStyle = `rgba(200, 255, 255, ${this.life})`;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#0ff';
        ctx.beginPath();
        ctx.moveTo(this.path[0].x, this.path[0].y);
        for(let i=1; i<this.path.length; i++) ctx.lineTo(this.path[i].x, this.path[i].y);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }
}

/**
 * ------------------------------------------------------------------
 * 3. MAIN LOOP & LOGIC
 * ------------------------------------------------------------------
 */
let audio = null;
const videoElement = document.getElementById('input_video');
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 1, // 0 is faster for mobile, 1 is better accuracy
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(onResults);

// Setup Camera with mobile-friendly constraints
const camera = new Camera(videoElement, {
    onFrame: async () => { await hands.send({image: videoElement}); },
    width: 1280, 
    height: 720
    // Note: MediaPipe Camera Utils forces a resolution, we handle aspect ratio in onResults
});

const startBtn = document.getElementById('start-btn');
startBtn.addEventListener('click', () => {
    document.getElementById('loading-screen').style.display = 'none';
    if(!audio) {
        audio = new AudioController();
        audio.ctx.resume();
    }
    camera.start();
});

// Simulated Load Time
setTimeout(() => {
    document.getElementById('loading-text').innerText = "System Ready";
    startBtn.style.display = 'block';
}, 2500);


function onResults(results) {
    // 1. Draw Video Feed with "Object-Fit: Cover" logic
    // This prevents the squished video look on portrait mobile screens
    ctx.save();
    ctx.clearRect(0, 0, width, height);
    
    const img = results.image;
    const screenRatio = width / height;
    const imgRatio = img.width / img.height;
    
    let drawW, drawH, startX, startY;

    if (screenRatio > imgRatio) {
        // Screen is wider than video (Landscape or PC)
        drawW = width;
        drawH = width / imgRatio;
        startX = 0;
        startY = (height - drawH) / 2;
    } else {
        // Screen is taller than video (Mobile Portrait)
        drawH = height;
        drawW = height * imgRatio;
        startX = (width - drawW) / 2;
        startY = 0;
    }

    // Update global state for coordinate mapping
    renderScale = { w: drawW, h: drawH, offsetX: startX, offsetY: startY };

    ctx.drawImage(img, startX, startY, drawW, drawH);

    // 2. Logic Detection
    let handsFound = false;
    let dist = 1000;

    if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
        const h1 = results.multiHandLandmarks[0][0]; // Wrist
        const h2 = results.multiHandLandmarks[1][0]; // Wrist
        
        // Convert to pixel space using Responsive Scale
        // We must map normalized coordinates (0-1) to the actual drawn video dimensions
        const p1 = { 
            x: h1.x * renderScale.w + renderScale.offsetX, 
            y: h1.y * renderScale.h + renderScale.offsetY 
        };
        const p2 = { 
            x: h2.x * renderScale.w + renderScale.offsetX, 
            y: h2.y * renderScale.h + renderScale.offsetY 
        };
        
        handCentroid.x = (p1.x + p2.x) / 2;
        handCentroid.y = (p1.y + p2.y) / 2;
        
        dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
        handsFound = true;
    }

    // STATE MACHINE
    
    // Condition to Charge: Two hands close together
    // Mobile tweak: slightly generous distance
    const chargeThresholdDist = Math.min(width, height) * 0.4; 
    
    if (handsFound && dist < chargeThresholdDist && !isFiring) {
        isHandsTogether = true;
        if (charge < 100) charge += 1.0; // Charge slightly faster on mobile
        
        if(audio) {
            audio.startCharge();
            audio.updateCharge(charge / 100);
        }

        if (charge > 50 && Math.random() > 0.7) {
            lightning.push(new Bolt(handCentroid.x, handCentroid.y, charge * 1.5));
        }

        for(let i=0; i<3; i++) {
            particles.push(new Particle('gather', handCentroid.x, handCentroid.y));
        }

    } else {
        isHandsTogether = false;
        if(audio) audio.stopCharge();
        
        if (charge > 40 && !isFiring) {
            isFiring = true;
            fireFrameCount = 60; 
            if(audio) audio.fireBlast();
            
            for(let i=0; i<50; i++) {
                particles.push(new Particle('debris', handCentroid.x, handCentroid.y));
            }
        }
    }

    if (!isHandsTogether && !isFiring && charge > 0) {
        charge -= 5;
    }

    // UI Updates
    document.getElementById('energy-bar').style.width = charge + "%";
    document.getElementById('instruction').innerText = isFiring ? "FIRING!" : (isHandsTogether ? "CHARGING..." : "ALIGN WRISTS");

    // 3. RENDERING EFFECTS (Additive)
    ctx.globalCompositeOperation = 'screen'; 

    // Charging Orb
    if (charge > 0 || isFiring) {
        const flicker = Math.random() * 10;
        const radius = (isFiring ? 150 : charge) + flicker;
        
        // Prevent gradient crash if radius is negative/zero
        const safeRadius = Math.max(0.1, radius);

        const grad = ctx.createRadialGradient(handCentroid.x, handCentroid.y, 10, handCentroid.x, handCentroid.y, safeRadius * 2);
        grad.addColorStop(0, '#fff'); 
        grad.addColorStop(0.3, '#0ff'); 
        grad.addColorStop(0.7, 'rgba(0, 100, 255, 0.5)'); 
        grad.addColorStop(1, 'rgba(0,0,0,0)');

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(handCentroid.x, handCentroid.y, safeRadius * 2, 0, Math.PI*2);
        ctx.fill();
    }

    // Firing Beam
    if (isFiring) {
        fireFrameCount--;
        if (fireFrameCount <= 0) {
            isFiring = false;
            charge = 0;
        }

        const shakeX = (Math.random() - 0.5) * 40;
        const shakeY = (Math.random() - 0.5) * 40;
        
        // Ensure beam covers whole screen regardless of aspect
        const maxDim = Math.max(width, height);
        
        const beamGrad = ctx.createRadialGradient(handCentroid.x + shakeX, handCentroid.y + shakeY, 50, handCentroid.x, handCentroid.y, maxDim);
        beamGrad.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        beamGrad.addColorStop(0.2, 'rgba(0, 255, 255, 0.6)');
        beamGrad.addColorStop(1, 'rgba(0, 0, 255, 0)');
        
        ctx.fillStyle = beamGrad;
        ctx.fillRect(0, 0, width, height); 
    }

    // Draw Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw(ctx);
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    // Draw Lightning
    for (let i = lightning.length - 1; i >= 0; i--) {
        lightning[i].draw(ctx);
        if (lightning[i].life <= 0) lightning.splice(i, 1);
    }

    ctx.restore();
}
</script>
</body>
</html>